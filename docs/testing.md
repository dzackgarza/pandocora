# Tiered Testing System

This project uses a tiered testing system to ensure code quality and catch errors early. Tests are organized into tiers, and each tier must pass before the next tier is executed.

## Directory Structure

-   `src/`: Contains the main source code for the extension.
-   `tests/`: Contains all test files.
    -   `tests/tier0/`: Basic sanity checks (e.g., compilation, critical functionality). These should be very fast.
    -   `tests/tier1/`: More comprehensive unit and integration tests.
    -   `tests/test_data/`: Contains data files used by tests.
    -   *(Additional tiers `tests/tierN/` can be added as needed)*
-   `docs/`: Contains documentation files, including this one.
-   `out/`: Contains compiled JavaScript code (generated by `npm run build` or `make build`).

## Running Tests

You can run tests using either `npm` or `make`.

### Using npm

-   `npm test`: Runs all test tiers sequentially. Tier N will only run if Tier N-1 passes.
-   `npm run typecheck`: Runs TypeScript type checking on the main codebase.

### Using make

The `Makefile` provides more granular control over the testing process.

-   `make test`: Runs all test tiers sequentially. This is equivalent to `npm test`.
-   `make test-tier0`: Runs only Tier 0 tests.
-   `make test-tier1`: Runs Tier 0, then Tier 1 tests. (Tier 1 will not run if Tier 0 fails).
    *(Similar targets like `make test-tierN` will be available if more tiers are added).*
-   `make test-file file=<path_to_test_file.test.ts>`: Runs a specific test file.
    *Example:* `make test-file file=tests/tier0/compilation.test.ts`
-   `make typecheck-tests`: Runs TypeScript type checking on all files within the `tests/` directory.

## Adding New Tests

1.  **Determine the appropriate tier** for your test.
    *   **Tier 0:** For critical, basic checks that should run very quickly. If this test fails, it likely indicates a fundamental problem with the codebase (e.g., it doesn't compile, or a core component is broken).
    *   **Tier 1 (and above):** For more specific unit tests, integration tests, or tests that might take longer to run.
2.  **Create your test file** in the corresponding `tests/tierN/` directory. Test files should end with `.test.ts`.
    *   *Example:* `tests/tier1/my-feature.test.ts`
3.  **Write your tests** using a testing framework like Mocha and an assertion library like Node.js's built-in `assert`.
    *   The `compilation.test.ts` in `tests/tier0/` provides a basic example.
4.  **Ensure your new tests pass** by running the specific tier (e.g., `make test-tier1`) or the specific file (`make test-file file=tests/tier1/my-feature.test.ts`).
5.  The `Makefile` will automatically pick up new `.test.ts` files in the tier directories.

## Test Execution Flow

The `Makefile` defines dependencies between test tiers. For example, `test-tier1` depends on `test-tier0`. This means `make test-tier1` will first execute all Tier 0 tests. If any Tier 0 test fails, the process will stop, and Tier 1 tests will not be executed.

The main `test` target depends on all defined test tiers, ensuring they run in the correct order.

## Current Tiers

-   **Tier 0:**
    -   `compilation.test.ts`: Checks that the main extension (`src/extension.ts`) can be imported and basic exports are present. This ensures fundamental code integrity and catch basic compilation or module resolution issues.
-   **Tier 1:**
    -   `linting.test.ts`: Programmatically runs ESLint on all TypeScript files in the `src/` and `tests/` directories. This test enforces coding standards and catches a wide range of potential bugs or stylistic issues early. It uses the configuration defined in `eslint.config.js`.
    -   `no-console-src.test.ts`: Specifically checks that no `console.log()` statements are present in the `src/` directory. This helps prevent accidental inclusion of debug statements in production code. Other `console` methods like `console.warn` or `console.error` are not currently restricted by this specific test but might be flagged by ESLint based on its configuration.

This system helps maintain a stable codebase by catching regressions and errors at the appropriate level of granularity.Tool output for `create_file_with_block`:

## Pre-commit Hook for Tier 1 Tests

To automatically run Tier 1 tests before committing, a pre-commit hook script is available at `scripts/git-hooks/pre-commit.sh`. This hook ensures that commits do not proceed if Tier 1 tests (which include Tier 0 tests as a prerequisite) are failing.

### Setup

To enable the hook:

1.  **Navigate to your local Git hooks directory:**
    ```bash
    cd .git/hooks/
    ```

2.  **Create a symbolic link** to the script (or copy it):
    *   From the `.git/hooks/` directory:
        ```bash
        ln -s ../../scripts/git-hooks/pre-commit.sh pre-commit
        ```
    *   Alternatively, you can copy the file:
        ```bash
        cp ../../scripts/git-hooks/pre-commit.sh pre-commit
        ```
        If you copy, ensure the copied file `pre-commit` is executable (`chmod +x pre-commit`). The original script in `scripts/git-hooks/` is already marked as executable in the repository.

3.  **Verify:** The `pre-commit` file should now exist in `.git/hooks/` and be executable.

Once set up, this hook will automatically run `make test-tier1` each time you attempt to `git commit`. If the tests fail, the commit will be aborted.

### Bypassing the Hook (Not Recommended)

If you need to bypass the pre-commit hook for a specific commit (e.g., for a work-in-progress commit that you don't intend to push yet), you can use the `--no-verify` option:

```bash
git commit --no-verify -m "Your commit message"
```

However, it's strongly recommended to ensure all tests pass before pushing changes to a shared repository.
